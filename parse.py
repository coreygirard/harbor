import re

def p(text,n=80):
    text = re.sub(r'[ ]\n',r' ',text)
    text = re.sub(r'\n[ ]',r' ',text)
    text = re.sub(r'\n',r' ',text)

    temp = []

    while len(text) > 0:
        if len(text) <= n:
            temp.append(text)
            text = []
            break

        t = n
        while t > 0 and text[t] != ' ':
            t -= 1
        if t == 0:
            while t < len(text) and text[t] != ' ':
                t += 1

        temp.append(text[:t])
        text = text[t+1:]

    return '\n'.join(temp)





def parse(line,lookup,patterns):
    '''
    >>> patterns = {'sample': '**{sample}**',
    ...            'another': '- *`{another}`*'}

    >>> parse('hello','another',patterns)
    '- *`hello`*'
    >>> parse('world','sample',patterns)
    '**world**'
    '''

    if lookup == 'p':
        return p(line)
    elif lookup == 'otherbuiltin':
        return line
    elif lookup in patterns.keys():
        return re.sub('{'+lookup+'}',line,patterns[lookup])

def applyPatterns(groups,patterns):
    r'''
    >>> groups = {'aaa/bbb/ccc': '{abc}[another] {def}[sample]\n'
    ...                          '{ghi}[another] {jkl}[sample]\n',
    ...           'iii/jjj/kkk': '{mno}[another] {pqr}[sample]\n'
    ...                          '{stu}[another] {vwx}[sample]\n'}

    >>> patterns = {'sample': '**{sample}**',
    ...             'another': '- *`{another}`*'}

    >>> expected = {'iii/jjj/kkk': '- *`mno`* **pqr**\n'
    ...                            '- *`stu`* **vwx**\n',
    ...             'aaa/bbb/ccc': '- *`abc`* **def**\n'
    ...                            '- *`ghi`* **jkl**\n'}

    >>> applyPatterns(groups,patterns) == expected
    True
    '''

    pattA,pattB = r'[^\{\}]*?',r'.*?'
    for p in groups.keys():
        temp = re.split(r'(\{'+pattA+r'\}\['+pattB+r'\])',groups[p])
        groups[p] = []
        for w in temp:
            match = re.fullmatch(r'\{('+pattA+r')\}\[('+pattB+r')\]',w)
            if match:
                fromStr,lookup = match.groups()
                groups[p].append(parse(fromStr,lookup,patterns))
            else:
                groups[p].append(w)
        groups[p] = ''.join(groups[p])

    #pprint(groups)

    '''
    for path in groups.keys():
        temp = groups[path]

        temp = '\n'.join(temp) + ' \n'
        temp = parse(temp,patterns)

        groups[path] = temp
    '''
    return groups




def makeAttrib():
    '''
    >>> a = makeAttrib()
    >>> type(a) == type('string')
    True
    '''
    attrib = '\n'.join(['<br>'
                      '<br>'
                      '<br>'
                      '<p align="center">'
                      '  <i>This documentation generated by <a href="{0}" title="{1}>{2}</a></i>'
                      '</p>'])
    attrib = attrib.format('https://www.github.com/crgirard/harbor',
                           'harbor: docs made simple',
                           'harbor')
    return attrib

def structure(comments,outline,verbose=False,credit=False):
    '''
    >>> c = {'aaa/bbb': 'hello,',
    ...      'aaa/ccc': 'world!'}

    >>> o = {'readme.md':['aaa',
    ...                   'aaa/bbb',
    ...                   'aaa/ccc']}

    >>> structure(c,o)
    {'readme.md': ['hello,', 'world!']}
    '''

    out = {}
    for filename,contents in outline.items():
        out[filename] = []
        for i in contents:
            if i in comments:
                out[filename].append(comments[i])
            elif verbose:
                print('\n\n\n --- NO TEXT ASSIGNED TO SECTION: {0} --- \n\n\n'.format(i))
        if credit:
            out[filename].append(makeAttrib())

    return out








