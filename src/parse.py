import re

def p(text,n=80):
    r'''
    Processes a paragraph of text marked with {...}[p], ensuring the .md file is wrapped nicely

    >>> r = p('testing testing testing '
    ...       'testing testing testing '
    ...       'testing testing testing '
    ...       'testing testing testing '
    ...       'testing testing testing '
    ...       'testing testing testing ')
    >>> r == str('testing testing testing testing testing '
    ...          'testing testing testing testing testing\n'
    ...          'testing testing testing testing testing '
    ...          'testing testing testing  \n')
    True
    '''

    text = re.sub(r'[ ]\n',r' ',text)
    text = re.sub(r'\n[ ]',r' ',text)
    text = re.sub(r'\n',r' ',text)

    temp = []

    while len(text) > 0:
        if len(text) <= n:
            temp.append(text)
            text = []
            break

        t = n
        while t > 0 and text[t] != ' ':
            t -= 1
        if t == 0:
            while t < len(text) and text[t] != ' ':
                t += 1

        temp.append(text[:t])
        text = text[t+1:]

    return '\n'.join(temp) + ' \n'





def parse(line,lookup,patterns):
    '''
    >>> patterns = {'sample': '**{sample}**',
    ...            'another': '- *`{another}`*'}

    >>> parse('hello','another',patterns)
    '- *`hello`*'
    >>> parse('world','sample',patterns)
    '**world**'
    '''

    if lookup == 'p':
        return p(line)
    elif lookup in patterns.keys():
        return re.sub('{'+lookup+'}',line,patterns[lookup])

class Match(object):
    def __init__(self,*args):
        self.loc = {'{': args[0],
                    '}': args[1]-1,
                    '[': args[1],
                    ']': args[2]-1}

        self.string = args[3]

        for s in '{}[]':
            assert(self.string[self.loc[s]] == s)

    def getOutput(self):
        return (self.string[self.loc['{']+1:self.loc['}']],
                self.string[self.loc['[']+1:self.loc[']']])

def getMacros(text,valid):
    r'''
    >>> text = '{abc}[another] {def}[sample]\n'
    >>> result = getMacros(text,['another', 'sample'])
    >>> result == ['',
    ...            ('abc', 'another'),
    ...            ' ',
    ...            ('def', 'sample'),
    ...            '\n']
    True
    >>> result = getMacros(text,['another'])
    >>> result == ['',
    ...            ('abc', 'another'),
    ...            ' {def}[sample]\n']
    True
    '''

    valid += ['p']

    temp = []

    patt = r'\}\[.+?\]'
    for m in re.finditer(patt,text):
        n = 1
        t = m.start()
        while n > 0 and t > 0:
            t -= 1
            if text[t] == '}':
                n += 1
            elif text[t] == '{':
                n -= 1

        a,b,c = [t,m.start()+1,m.end()]
        if text[b+1:c-1] in valid:
            temp.append(Match(a,b,c,text))

    if len(temp) == 0:
        return [text]

    out = [temp.pop(0)]
    for e in temp:
        if e.loc['{'] > out[-1].loc[']']:
            out.append(e)

    trailing = 0
    temp = []
    for e in out:
        temp.append(text[trailing:e.loc['{']])
        temp.append(e.getOutput())
        trailing = e.loc[']']+1
    temp.append(text[trailing:])

    return temp

def applyPatterns(groups,patterns):
    r'''
    >>> groups = {'aaa/bbb/ccc': '{abc}[another] {def}[sample]\n'
    ...                          '{ghi}[another] {jkl}[sample]\n',
    ...           'iii/jjj/kkk': '{mno}[another] {pqr}[sample]\n'
    ...                          '{stu}[another] {vwx}[sample]\n'}

    >>> patterns = {'sample': '**{sample}**',
    ...             'another': '- *`{another}`*'}

    >>> expected = {'iii/jjj/kkk': '- *`mno`* **pqr**\n'
    ...                            '- *`stu`* **vwx**\n',
    ...             'aaa/bbb/ccc': '- *`abc`* **def**\n'
    ...                            '- *`ghi`* **jkl**\n'}

    >>> applyPatterns(groups,patterns) == expected
    True
    '''

    for k,v in groups.items():
        temp = getMacros(v,list(patterns.keys()))
        groups[k] = []

        for e in temp:
            if type(e) == type('string'):
                groups[k].append(e)
            else:
                groups[k].append(parse(e[0],e[1],patterns))
        groups[k] = ''.join(groups[k])

    return groups



def makeAttrib():
    '''
    >>> a = makeAttrib()
    >>> type(a) == type('string')
    True
    '''
    attrib = '\n'.join(['<br>'
                        '<br>',
                        '<br>',
                        '',
                        '*This documentation generated by [{2}]({0})*'])
    attrib = attrib.format('https://www.github.com/crgirard/harbor',
                           'harbor: docs made simple',
                           'harbor')
    return attrib

def structure(comments,outline,verbose=False,credit=False):
    '''
    >>> c = {'aaa/bbb': 'hello,',
    ...      'aaa/ccc': 'world!'}

    >>> o = {'readme.md':['aaa',
    ...                   'aaa/bbb',
    ...                   'aaa/ccc']}

    >>> structure(c,o)
    {'readme.md': ['hello,', 'world!']}
    '''

    out = {}
    for filename,contents in outline.items():
        out[filename] = []
        for i in contents:
            if i in comments:
                out[filename].append(comments[i])
            elif verbose:
                print('\n\n\n --- NO TEXT ASSIGNED TO SECTION: {0} --- \n\n\n'.format(i))
        if credit:
            out[filename].append(makeAttrib())

    return out
